"""
原子クラスター構築用プログラム
AtomicEditor.pyが必要
2022/11/16  Hiroto Tomita
Version 1
"""
import copy
import AtomicEditor
import numpy as np
import subprocess
import tkinter as tk
import tkinter.filedialog
from decimal import Decimal, ROUND_HALF_UP

ae = AtomicEditor.AE()
root = tk.Tk()  # ルートウィンドウの作成
root.withdraw()  # ルートウィンドウの非表示
VESTA = r"C:\Users\holo\VESTA-win64\VESTA.exe"
# VESTA = r"C:\Users\Isama\VESTA-win64\VESTA.exe"


""" //////////////////////////////////////////////////////////////////////////////////////////////////////////////// """

# 基本格子ベクトルのndarray(3×3)行列 <2D-ndarray>
TRANSLATION_VECTOR = np.array([[3.1880000, 0.0, 0.0], [-1.5940000, 2.7608890, 0.0], [0.0, 0.0, 5.1856100]])
# TRANSLATION_VECTOR = np.array([[6.376000, 0.0, 0.0], [-3.188000, 5.521778, 0.0], [0.0, 0.0, 35.1856100]])
# TRANSLATION_VECTOR = np.array([[9.564000, 0.0, 0.0], [0.0, 5.521778, 0.0], [0.0, 0.0, 35.1856100]])
# エミッター原子のインデックスを要素としたリスト <list>
EMITTER_ATOM_INDEX_LIST = [4, 5, 6, 7]
# 面対象のクラスターを作成するかどうか (True or False)
YZ_PLANE_SYMMETRY = False
ZX_PLANE_SYMMETRY = False
# クラスターの形状(SPHERICAL, COLUMN, CUBOID, SLAB) <str>
CLUSTER_SHAPE = "SPHERICAL"
# CLUSTER_SHAPE = "CUBOID"
RADIUS = 12.0
X_MAXIMUM = 15
X_MINIMUM = -15
Y_MAXIMUM = 15
Y_MINIMUM = -15
Z_MAXIMUM = 12.0
Z_MINIMUM = -2.0
# Z_MINIMUM = -1.0

BOND_LENGTH_MIN = 1.2

""" //////////////////////////////////////////////////////////////////////////////////////////////////////////////// """

INPUT_FILE = tkinter.filedialog.askopenfilename(filetypes=[('XTLファイル', '*.xtl'), ('XYZファイル', '*.xyz')],
                                                title="入力ファイル")
if INPUT_FILE == '':
    exit()
OUTPUT_FILE = tkinter.filedialog.asksaveasfilename(filetypes=[('XYZファイル', '*.xyz')], defaultextension='.xyz',
                                                   title="保存")
OUTPUT_FILE = OUTPUT_FILE.replace(r"/", "\\")
if OUTPUT_FILE == '':
    exit()
print("output_directory:\t" + str(OUTPUT_FILE))


def main():
    if INPUT_FILE[-4:] == ".xtl":
        l_unit, trans_vec = ae.load_xtl_file(INPUT_FILE)
        l_text = []
        if CLUSTER_SHAPE == "SPHERICAL":
            for e in EMITTER_ATOM_INDEX_LIST:
                cluster = ae.build_spherical_cluster(ae.move_emitter_atom_to_origin(l_unit, e), trans_vec,
                                                     radius=RADIUS, min_bond_length=BOND_LENGTH_MIN)
                # Write down the atomic data
                text = str(len(cluster)) + "\nGenerated by CrystalBuilder.py\n"
                for atom in cluster:
                    text += "%2s" % atom['e']
                    text += "%12f" % (
                        float(Decimal(str(atom['pos'][0])).quantize(Decimal('0.000001'), rounding=ROUND_HALF_UP)))
                    text += "%12f" % (
                        float(Decimal(str(atom['pos'][1])).quantize(Decimal('0.000001'), rounding=ROUND_HALF_UP)))
                    text += "%12f\n" % (
                        float(Decimal(str(atom['pos'][2])).quantize(Decimal('0.000001'), rounding=ROUND_HALF_UP)))
                l_text.append(copy.deepcopy(text))
            # Save the crystal file
            fp = open(OUTPUT_FILE, mode="w", encoding="utf-8")
            for i in range(len(l_text)):
                fp.write(l_text[i])
            fp.close()
        elif CLUSTER_SHAPE == "COLUMN":
            for e in EMITTER_ATOM_INDEX_LIST:
                cluster = ae.build_column_cluster(ae.move_emitter_atom_to_origin(l_unit, e), trans_vec,
                                                  radius=RADIUS, z_max=Z_MAXIMUM, z_min=Z_MINIMUM,
                                                  min_bond_length=BOND_LENGTH_MIN)
                # Write down the atomic data
                text = str(len(cluster)) + "\nGenerated by CrystalBuilder.py\n"
                for atom in cluster:
                    text += "%2s" % atom['e']
                    text += "%12f" % (
                        float(Decimal(str(atom['pos'][0])).quantize(Decimal('0.000001'), rounding=ROUND_HALF_UP)))
                    text += "%12f" % (
                        float(Decimal(str(atom['pos'][1])).quantize(Decimal('0.000001'), rounding=ROUND_HALF_UP)))
                    text += "%12f\n" % (
                        float(Decimal(str(atom['pos'][2])).quantize(Decimal('0.000001'), rounding=ROUND_HALF_UP)))
                l_text.append(copy.deepcopy(text))
            # Save the crystal file
            fp = open(OUTPUT_FILE, mode="w", encoding="utf-8")
            for i in range(len(l_text)):
                fp.write(l_text[i])
            fp.close()
        elif CLUSTER_SHAPE == "CUBOID":
            for e in EMITTER_ATOM_INDEX_LIST:
                cluster = ae.build_cuboid_cluster(ae.move_emitter_atom_to_origin(l_unit, e), trans_vec,
                                                  x_max=X_MAXIMUM, x_min=X_MINIMUM,
                                                  y_max=Y_MAXIMUM, y_min=Y_MINIMUM,
                                                  z_max=Z_MAXIMUM, z_min=Z_MINIMUM, min_bond_length=BOND_LENGTH_MIN)
                # Write down the atomic data
                text = str(len(cluster)) + "\nGenerated by CrystalBuilder.py\n"
                for atom in cluster:
                    text += "%2s" % atom['e']
                    text += "%12f" % (float(Decimal(str(atom['pos'][0])).quantize(Decimal('0.000001'), rounding=ROUND_HALF_UP)))
                    text += "%12f" % (float(Decimal(str(atom['pos'][1])).quantize(Decimal('0.000001'), rounding=ROUND_HALF_UP)))
                    text += "%12f\n" % (float(Decimal(str(atom['pos'][2])).quantize(Decimal('0.000001'), rounding=ROUND_HALF_UP)))
                l_text.append(copy.deepcopy(text))
            # Save the crystal file
            fp = open(OUTPUT_FILE, mode="w", encoding="utf-8")
            for i in range(len(l_text)):
                fp.write(l_text[i])
            fp.close()
        elif CLUSTER_SHAPE == "SLAB":
            ae.save_slab_models(l_unit, trans_vec, EMITTER_ATOM_INDEX_LIST,
                                OUTPUT_FILE, RADIUS, YZ_PLANE_SYMMETRY, ZX_PLANE_SYMMETRY)
    elif INPUT_FILE[-4:] == ".xyz":
        l_unit = ae.load_xyz_file(INPUT_FILE)
        if CLUSTER_SHAPE == "SPHERICAL":
            ae.save_spherical_clusters(l_unit, TRANSLATION_VECTOR, EMITTER_ATOM_INDEX_LIST,
                                       OUTPUT_FILE, RADIUS, YZ_PLANE_SYMMETRY, ZX_PLANE_SYMMETRY)
        elif CLUSTER_SHAPE == "COLUMN":
            ae.save_column_clusters(l_unit, TRANSLATION_VECTOR, EMITTER_ATOM_INDEX_LIST,
                                    OUTPUT_FILE, RADIUS, Z_MAXIMUM, Z_MINIMUM, YZ_PLANE_SYMMETRY, ZX_PLANE_SYMMETRY)
        elif CLUSTER_SHAPE == "CUBOID":
            ae.save_cuboid_clusters(l_unit, TRANSLATION_VECTOR, EMITTER_ATOM_INDEX_LIST,
                                    OUTPUT_FILE, X_MAXIMUM, X_MINIMUM, Y_MAXIMUM, Y_MINIMUM, Z_MAXIMUM, Z_MINIMUM,
                                    YZ_PLANE_SYMMETRY, ZX_PLANE_SYMMETRY)
        elif CLUSTER_SHAPE == "SLAB":
            ae.save_slab_models(l_unit, TRANSLATION_VECTOR, EMITTER_ATOM_INDEX_LIST,
                                OUTPUT_FILE, RADIUS, YZ_PLANE_SYMMETRY, ZX_PLANE_SYMMETRY)

    # subprocess.Popen([VESTA, "-open", OUTPUT_FILE])


if __name__ == '__main__':
    main()
